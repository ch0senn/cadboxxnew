/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["GLTFUtils"] = factory();
	else
		root["GLTFUtils"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/animation.ts":
/*!**************************!*\
  !*** ./src/animation.ts ***!
  \**************************/
/*! namespace exports */
/*! export Animation [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animation\": () => /* binding */ Animation\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Animation = /** @class */ (function () {\n    function Animation(path, name) {\n        if (name === void 0) { name = \"\"; }\n        this.keyframes = [];\n        this.name = \"\";\n        this.path = path;\n        this.name = name;\n    }\n    Animation.prototype.addKeyframe = function (time, value, interpType, extras) {\n        console.assert(value.length >= 3);\n        var kf = {\n            interpType: interpType,\n            time: time,\n            value: value,\n        };\n        if (interpType === _types__WEBPACK_IMPORTED_MODULE_0__.InterpolationMode.CUBICSPLINE) {\n            var ext = {};\n            if (extras) {\n                if (extras.inTangent)\n                    ext.inTangent = extras.inTangent;\n                if (extras.inTangentWeight)\n                    ext.inTangentWeight = extras.inTangentWeight;\n                if (extras.outTangent)\n                    ext.outTangent = extras.outTangent;\n                if (extras.outTangentWeight)\n                    ext.outTangentWeight = extras.outTangentWeight;\n            }\n            if (Object.keys(ext).length > 0) {\n                kf.extras = ext;\n            }\n        }\n        this.keyframes.push(kf);\n    };\n    return Animation;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/animation.ts?");

/***/ }),

/***/ "./src/asset.ts":
/*!**********************!*\
  !*** ./src/asset.ts ***!
  \**********************/
/*! namespace exports */
/*! export GLTFAsset [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFAsset\": () => /* binding */ GLTFAsset\n/* harmony export */ });\nvar GLTFAsset = /** @class */ (function () {\n    function GLTFAsset() {\n        this.copyright = \"\";\n        this.defaultScene = 0;\n        this.generator = \"glTF-js-utils\";\n        this._scenes = [];\n    }\n    GLTFAsset.prototype.setDefaultScene = function (scene) {\n        if (typeof scene === \"number\")\n            this.defaultScene = scene;\n        else {\n            var sceneIndex = this._scenes.indexOf(scene);\n            if (sceneIndex === -1)\n                throw new Error(\"Scene passed to setDefaultScene was not found.\");\n            this.defaultScene = sceneIndex;\n        }\n    };\n    GLTFAsset.prototype.addScene = function (scene) {\n        if (this._scenes.indexOf(scene) >= 0)\n            throw new Error(\"Scene passed to addScene was added prior.\");\n        this._scenes.push(scene);\n    };\n    GLTFAsset.prototype.removeScene = function (scene) {\n        var sceneIndex = this._scenes.indexOf(scene);\n        if (sceneIndex >= 0)\n            this._scenes.splice(sceneIndex, 1);\n    };\n    GLTFAsset.prototype.forEachScene = function (fn) {\n        this._scenes.forEach(fn);\n    };\n    return GLTFAsset;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/asset.ts?");

/***/ }),

/***/ "./src/buffer.ts":
/*!***********************!*\
  !*** ./src/buffer.ts ***!
  \***********************/
/*! namespace exports */
/*! export Buffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export BufferView [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Buffer\": () => /* binding */ Buffer,\n/* harmony export */   \"BufferView\": () => /* binding */ BufferView\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Buffer = /** @class */ (function () {\n    function Buffer(gltf) {\n        this._bufferViews = [];\n        this._finalized = false;\n        this._gltf = gltf;\n        if (!gltf.buffers)\n            gltf.buffers = [];\n        this._index = gltf.buffers.length;\n        var gltfBuffer = {\n            byteLength: -1,\n        };\n        gltf.buffers.push(gltfBuffer);\n        this._gltfBuffer = gltfBuffer;\n    }\n    Buffer.prototype.getIndex = function () {\n        return this._index;\n    };\n    Buffer.prototype.addBufferView = function (componentType, dataType) {\n        if (this._finalizePromise)\n            throw new Error(\"Cannot add buffer view after finalizing buffer\");\n        var view = new BufferView(this, this._gltf, componentType, dataType);\n        this._bufferViews.push(view);\n        return view;\n    };\n    Buffer.prototype.getByteOffset = function (bufferView) {\n        var byteOffset = 0;\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\n            var view = _a[_i];\n            if (view === bufferView) {\n                return byteOffset;\n            }\n            byteOffset += view.getSize();\n        }\n        throw \"Given bufferView was not present in this buffer\";\n    };\n    Buffer.prototype.getViewFinalizePromises = function (targetBufferView) {\n        var promises = [];\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\n            var view = _a[_i];\n            if (targetBufferView && view === targetBufferView) {\n                return promises;\n            }\n            promises.push(view.finalized);\n        }\n        return promises;\n    };\n    Buffer.prototype.getArrayBuffer = function () {\n        if (!this._finalized)\n            throw new Error(\"Cannot get ArrayBuffer from Buffer before it is finalized\");\n        var byteLength = this._getTotalSize();\n        var buffer = new ArrayBuffer(byteLength);\n        var currentIndex = 0;\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\n            var bufferView = _a[_i];\n            bufferView.writeOutToBuffer(buffer, currentIndex);\n            currentIndex += bufferView.getSize();\n        }\n        return buffer;\n    };\n    Buffer.prototype.finalize = function () {\n        var _this = this;\n        if (this._finalizePromise)\n            throw new Error(\"Buffer \" + this._index + \" was already finalized\");\n        this._finalizePromise = new Promise(function (resolve) {\n            resolve(Promise.all(_this.getViewFinalizePromises()));\n        }).then(function () {\n            _this._finalized = true;\n            var arrayBuffer = _this.getArrayBuffer();\n            _this._gltfBuffer.byteLength = arrayBuffer.byteLength;\n            _this._gltfBuffer.uri = arrayBuffer; // Still not totally finalized, see stringify\n        });\n        this._gltf.extras.promises.push(this._finalizePromise);\n        return this._finalizePromise;\n    };\n    Buffer.prototype._getTotalSize = function () {\n        var byteLength = 0;\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\n            var bufferView = _a[_i];\n            byteLength += bufferView.getSize();\n        }\n        return byteLength;\n    };\n    return Buffer;\n}());\n\nvar BufferView = /** @class */ (function () {\n    function BufferView(buffer, gltf, componentType, dataType) {\n        this._data = [];\n        this._finalized = false;\n        this._accessorIndex = -1;\n        this._accessorAttr = null;\n        this._accessorMin = null;\n        this._accessorMax = null;\n        this._buffer = buffer;\n        this._componentType = componentType;\n        this._dataType = dataType;\n        if (!gltf.bufferViews)\n            gltf.bufferViews = [];\n        this._index = gltf.bufferViews.length;\n        this._gltfBufferView = {\n            buffer: buffer.getIndex(),\n            byteLength: -1,\n        };\n        var elementSize = this._getElementSize();\n        if (elementSize >= 4) { // Not a very good check.\n            this._gltfBufferView.byteStride = elementSize;\n        }\n        gltf.bufferViews.push(this._gltfBufferView);\n    }\n    BufferView.prototype.getBuffer = function () {\n        return this._buffer;\n    };\n    BufferView.prototype.getIndex = function () {\n        return this._index;\n    };\n    BufferView.prototype.push = function (item) {\n        var writeIndex = this._data.length;\n        this._data.push(item);\n        if (this._accessorIndex >= 0) {\n            var minmaxIndex = writeIndex % this._numComponentsForDataType();\n            if (!this._accessorMin || !this._accessorMax) {\n                throw new Error(\"Unexpected accessor state\");\n            }\n            var currentMin = this._accessorMin[minmaxIndex];\n            if (typeof currentMin !== \"number\")\n                this._accessorMin[minmaxIndex] = item;\n            else\n                this._accessorMin[minmaxIndex] = Math.min(currentMin, item);\n            var currentMax = this._accessorMax[minmaxIndex];\n            if (typeof currentMax !== \"number\")\n                this._accessorMax[minmaxIndex] = item;\n            else\n                this._accessorMax[minmaxIndex] = Math.max(currentMax, item);\n        }\n    };\n    BufferView.prototype.getDataSize = function () {\n        return this._data.length * this._sizeOfComponentType();\n    };\n    BufferView.prototype.getSize = function () {\n        // Technically there are some cases where the data could be more compact,\n        // but to be safe, we just always align each view to 4 bytes.\n        return makeDivisibleBy(this.getDataSize(), 4);\n    };\n    BufferView.prototype.getByteOffset = function () {\n        if (!this._finalized)\n            throw new Error(\"Cannot get BufferView offset until it is finalized\");\n        return this._buffer.getByteOffset(this);\n    };\n    BufferView.prototype.writeOutToBuffer = function (buffer, startIndex) {\n        if (startIndex === void 0) { startIndex = this.getSize(); }\n        var dataView = new DataView(buffer, startIndex);\n        var sizeOfComponentType = this._sizeOfComponentType();\n        for (var i = 0; i < this._data.length; i++) {\n            var val = this._data[i];\n            this._writeValue(dataView, i * sizeOfComponentType, val);\n        }\n    };\n    BufferView.prototype.writeAsync = function (buffer) {\n        var _this = this;\n        if (this._asyncWritePromise)\n            throw new Error(\"Can't write multiple buffer view values asynchronously\");\n        this._asyncWritePromise = buffer.then(function (arrayBuffer) {\n            var uintArray = new Uint8Array(arrayBuffer);\n            for (var i = 0; i < uintArray.byteLength; i++) {\n                _this._data.push(uintArray[i]);\n            }\n            delete _this._asyncWritePromise;\n        });\n        return this._asyncWritePromise;\n    };\n    BufferView.prototype.startAccessor = function (attr) {\n        if (attr === void 0) { attr = null; }\n        if (this._accessorIndex >= 0)\n            throw \"Accessor was started without ending the previous one\";\n        this._accessorIndex = this._data.length;\n        this._accessorAttr = attr;\n        this._accessorMin = new Array(this._numComponentsForDataType());\n        this._accessorMax = new Array(this._numComponentsForDataType());\n    };\n    BufferView.prototype.endAccessor = function () {\n        if (this._accessorIndex < 0)\n            throw new Error(\"An accessor was not started, but was attempted to be ended\");\n        var elementSize = this._getElementSize();\n        var numComponentsForDataType = this._numComponentsForDataType();\n        var numElements = (this._data.length - this._accessorIndex) / numComponentsForDataType;\n        if (numElements % 1)\n            throw new Error(\"An accessor was ended with missing component values\");\n        if (!this._accessorMin || !this._accessorMax) {\n            throw new Error(\"Unexpected accessor state\");\n        }\n        for (var i = 0; i < this._accessorMin.length; i++) {\n            if (typeof this._accessorMin[i] !== \"number\")\n                this._accessorMin[i] = 0;\n            if (typeof this._accessorMax[i] !== \"number\")\n                this._accessorMax[i] = 0;\n        }\n        var info = {\n            byteOffset: elementSize * (this._accessorIndex / numComponentsForDataType),\n            componentType: this._componentType,\n            count: numElements,\n            type: this._dataType,\n            min: this._accessorMin,\n            max: this._accessorMax,\n        };\n        switch (this._accessorAttr) {\n            case \"TEXCOORD_0\":\n            case \"TEXCOORD_1\":\n            case \"COLOR_0\":\n                switch (this._componentType) {\n                    case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE:\n                    case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_SHORT:\n                        info.normalized = true;\n                        break;\n                }\n                break;\n        }\n        this._accessorIndex = -1;\n        this._accessorAttr = null;\n        this._accessorMin = null;\n        this._accessorMax = null;\n        return info;\n    };\n    Object.defineProperty(BufferView.prototype, \"finalized\", {\n        get: function () {\n            var _this = this;\n            if (!this._finalizedPromise) {\n                if (this._finalized) {\n                    return this._finalizedPromise = Promise.resolve();\n                }\n                else {\n                    return this._finalizedPromise = new Promise(function (resolve) {\n                        _this._finalizedPromiseResolve = resolve;\n                    });\n                }\n            }\n            return this._finalizedPromise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BufferView.prototype.finalize = function () {\n        var _this = this;\n        var gltfBufferView = this._gltfBufferView;\n        return new Promise(function (resolve) {\n            var prereqs = _this._buffer.getViewFinalizePromises(_this);\n            if (_this._asyncWritePromise)\n                prereqs.push(_this._asyncWritePromise);\n            resolve(Promise.all(prereqs));\n        }).then(function () {\n            _this._finalized = true;\n            gltfBufferView.byteOffset = _this.getByteOffset();\n            gltfBufferView.byteLength = _this.getDataSize();\n            if (_this._finalizedPromiseResolve)\n                _this._finalizedPromiseResolve();\n        });\n    };\n    BufferView.prototype._getElementSize = function () {\n        return this._sizeOfComponentType() * this._numComponentsForDataType();\n    };\n    BufferView.prototype._sizeOfComponentType = function () {\n        switch (this._componentType) {\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.BYTE:\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE:\n                return 1;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.SHORT:\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_SHORT:\n                return 2;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_INT:\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT:\n                return 4;\n        }\n        throw \"Unrecognized component type \" + this._componentType;\n    };\n    BufferView.prototype._numComponentsForDataType = function () {\n        switch (this._dataType) {\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.SCALAR:\n                return 1;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC2:\n                return 2;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3:\n                return 3;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC4:\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT2:\n                return 4;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT3:\n                return 9;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT4:\n                return 16;\n        }\n        throw \"Unsupported data type\";\n    };\n    BufferView.prototype._writeValue = function (dataView, index, val) {\n        switch (this._componentType) {\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.BYTE:\n                dataView.setInt8(index, val);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE:\n                dataView.setUint8(index, val);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.SHORT:\n                dataView.setInt16(index, val, true);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_SHORT:\n                dataView.setUint16(index, val, true);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_INT:\n                dataView.setUint32(index, val, true);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT:\n                dataView.setFloat32(index, val, true);\n                break;\n            default:\n                throw \"Unsupported data type\";\n        }\n    };\n    return BufferView;\n}());\n\nfunction makeDivisibleBy(num, by) {\n    return by * Math.ceil(num / by);\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/buffer.ts?");

/***/ }),

/***/ "./src/glb.ts":
/*!********************!*\
  !*** ./src/glb.ts ***!
  \********************/
/*! namespace exports */
/*! export createGLBBuffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createGLBBuffer\": () => /* binding */ createGLBBuffer\n/* harmony export */ });\nvar GLB_HEADER_SIZE = 12;\nvar GLB_CHUNK_HEADER_SIZE = 8;\nvar GLB_MAGIC = 0x46546C67;\nvar GLTF_VERSION = 2;\nvar GLBChunkType;\n(function (GLBChunkType) {\n    GLBChunkType[GLBChunkType[\"JSON\"] = 1313821514] = \"JSON\";\n    GLBChunkType[GLBChunkType[\"BIN\"] = 5130562] = \"BIN\";\n})(GLBChunkType || (GLBChunkType = {}));\nfunction createGLBBuffer(json, bin) {\n    if (!json)\n        throw new Error(\"GLB requires a JSON glTF chunk\");\n    var glbLength = GLB_HEADER_SIZE;\n    glbLength += GLB_CHUNK_HEADER_SIZE;\n    var encodedJSON = textToArrayBuffer(json);\n    var jsonChunkSize = makeDivisibleBy(encodedJSON.byteLength, 4);\n    glbLength += jsonChunkSize;\n    if (bin) {\n        glbLength += GLB_CHUNK_HEADER_SIZE;\n        glbLength += bin.byteLength; // Already rounded\n        if (bin.byteLength % 4)\n            throw new Error(\"Expected BIN chunk length to be divisible by 4 at this point\");\n    }\n    var glbBuffer = new ArrayBuffer(glbLength);\n    var glbDataView = new DataView(glbBuffer);\n    writeHeader(glbDataView, glbLength);\n    // Chunk 0 (JSON)\n    var offset = writeChunk(glbDataView, encodedJSON, 12, GLBChunkType.JSON, 0x20);\n    // Chunk 1 (Binary Buffer)\n    if (bin) {\n        writeChunk(glbDataView, bin, offset, GLBChunkType.BIN);\n    }\n    return glbBuffer;\n}\nfunction writeHeader(out, glbLength) {\n    out.setUint32(0, GLB_MAGIC, true);\n    out.setUint32(4, GLTF_VERSION, true);\n    out.setUint32(8, glbLength, true);\n}\nfunction writeChunk(out, chunk, offset, chunkType, pad) {\n    if (pad === void 0) { pad = 0; }\n    var chunkLength = makeDivisibleBy(chunk.byteLength, 4);\n    out.setUint32(offset, chunkLength, true);\n    out.setUint32(offset += 4, chunkType, true);\n    writeArrayBuffer(out.buffer, chunk, offset += 4, 0, chunk.byteLength);\n    offset += chunk.byteLength;\n    while (offset % 4) {\n        if (pad) {\n            out.setUint8(offset, pad);\n        }\n        offset++;\n    }\n    return offset;\n}\nfunction textToArrayBuffer(json) {\n    return (new TextEncoder()).encode(json).buffer;\n}\nfunction writeArrayBuffer(target, src, targetOffset, srcOffset, byteLength) {\n    new Uint8Array(target, targetOffset, byteLength).set(new Uint8Array(src, srcOffset, byteLength), 0);\n}\nfunction makeDivisibleBy(num, by) {\n    return by * Math.ceil(num / by);\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/glb.ts?");

/***/ }),

/***/ "./src/gltf.ts":
/*!*********************!*\
  !*** ./src/gltf.ts ***!
  \*********************/
/*! namespace exports */
/*! export addAccessor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addAnimations [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addBuffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addScenes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addSkin [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createEmptyGLTF [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createEmptyGLTF\": () => /* binding */ createEmptyGLTF,\n/* harmony export */   \"addScenes\": () => /* binding */ addScenes,\n/* harmony export */   \"addSkin\": () => /* binding */ addSkin,\n/* harmony export */   \"addAnimations\": () => /* binding */ addAnimations,\n/* harmony export */   \"addBuffer\": () => /* binding */ addBuffer,\n/* harmony export */   \"addAccessor\": () => /* binding */ addAccessor\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ \"./src/buffer.ts\");\n/* harmony import */ var _imageutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./imageutils */ \"./src/imageutils.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n\n\n\n\nfunction createEmptyGLTF() {\n    return {\n        asset: {\n            version: \"2.0\",\n        },\n        extras: {\n            options: {},\n            binChunkBuffer: null,\n            promises: [],\n            nodeIndices: new Map(),\n        }\n    };\n}\nfunction addScenes(gltf, asset) {\n    gltf.scene = asset.defaultScene;\n    var doingGLB = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB\n        || gltf.extras.options.imageOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.ImageOutputType.GLB;\n    if (doingGLB) {\n        gltf.extras.binChunkBuffer = addBuffer(gltf);\n    }\n    asset.forEachScene(function (scene) {\n        addScene(gltf, scene);\n    });\n    if (doingGLB) {\n        gltf.extras.binChunkBuffer.finalize();\n    }\n}\nfunction addScene(gltf, scene) {\n    if (!gltf.scenes)\n        gltf.scenes = [];\n    var gltfScene = {};\n    if (scene.name)\n        gltfScene.name = scene.name;\n    scene.forEachNode(function (node) {\n        if (!gltfScene.nodes)\n            gltfScene.nodes = [];\n        var index = addNode(gltf, node);\n        gltfScene.nodes.push(index);\n    });\n    gltf.scenes.push(gltfScene);\n}\nfunction addNode(gltf, node) {\n    var existingIndex = getNodeIndex(gltf, node);\n    if (existingIndex >= 0) {\n        return existingIndex;\n    }\n    if (!gltf.nodes)\n        gltf.nodes = [];\n    var gltfNode = {};\n    if (node.name)\n        gltfNode.name = node.name;\n    var translation = node.getTranslation();\n    if (translation.x !== 0 || translation.y !== 0 || translation.z !== 0)\n        gltfNode.translation = translation.toArray();\n    var rotation = node.getRotationQuaternion();\n    if (rotation.x !== 0 || rotation.y !== 0 || rotation.z !== 0 || rotation.w !== 1)\n        gltfNode.rotation = rotation.toArray();\n    var scale = node.getScale();\n    if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1)\n        gltfNode.scale = scale.toArray();\n    var addedIndex = gltf.nodes.length;\n    setNodeIndex(gltf, node, addedIndex);\n    gltf.nodes.push(gltfNode);\n    if (node.animations.length > 0) {\n        addAnimations(gltf, node.animations, addedIndex);\n    }\n    if (node.mesh) {\n        gltfNode.mesh = addMesh(gltf, node.mesh);\n    }\n    node.forEachNode(function (node) {\n        if (!gltfNode.children)\n            gltfNode.children = [];\n        var index = addNode(gltf, node);\n        gltfNode.children.push(index);\n    });\n    if (node.skin) {\n        gltfNode.skin = addSkin(gltf, node.skin, node);\n    }\n    return addedIndex;\n}\nfunction getJointIndexAndInverseBindMatrices(gltf, node) {\n    var nodeIndex = getNodeIndex(gltf, node);\n    if (nodeIndex === -1) {\n        throw new Error(\"Node should be added to gltf before calling getJointIndexAndInverseBindMatrices\");\n    }\n    var joints = [nodeIndex];\n    var ibms = [node.inverseBindMatrix];\n    node.forEachNode(function (node) {\n        var data = getJointIndexAndInverseBindMatrices(gltf, node);\n        joints = joints.concat(data[0]);\n        ibms = ibms.concat(data[1]);\n    });\n    return [joints, ibms];\n}\nfunction addSkin(gltf, skin, node) {\n    if (!gltf.skins) {\n        gltf.skins = [];\n    }\n    var addedIndex = gltf.skins.length;\n    var gltfSkin = {\n        joints: []\n    };\n    gltf.skins.push(gltfSkin);\n    // add name (if exists)\n    if (skin.name.length > 0)\n        gltfSkin.name = skin.name;\n    // add skeleton (if exists)\n    var skeletonNode = skin.skeletonNode;\n    if (skeletonNode) {\n        var existingIndex = getNodeIndex(gltf, skeletonNode);\n        if (existingIndex === -1) {\n            gltfSkin.skeleton = addNode(gltf, skeletonNode);\n        }\n        else {\n            gltfSkin.skeleton = existingIndex;\n        }\n    }\n    // add joints (required) and inversebindmatrices [IBM], if necessary\n    var rootNode = skeletonNode ? skeletonNode : node;\n    var data = getJointIndexAndInverseBindMatrices(gltf, rootNode);\n    gltfSkin.joints = data[0];\n    var ibms = data[1];\n    // check if there are any non default IBMs, and if so, create a new accessor\n    var hasIBM = false;\n    for (var _i = 0, ibms_1 = ibms; _i < ibms_1.length; _i++) {\n        var m = ibms_1[_i];\n        if (m && m.rows === 4 && m.cols === 4 && !_math__WEBPACK_IMPORTED_MODULE_2__.Matrix4x4.IsIdentity(m)) {\n            hasIBM = true;\n            break;\n        }\n    }\n    if (!hasIBM) {\n        return addedIndex;\n    }\n    // init skin buffer\n    var singleGLBBuffer = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB;\n    var skinBuffer = singleGLBBuffer ? gltf.extras.binChunkBuffer : addBuffer(gltf);\n    // init skin bufferView\n    var skinBufferView = skinBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT4);\n    // init skin accessor\n    skinBufferView.startAccessor();\n    for (var _a = 0, ibms_2 = ibms; _a < ibms_2.length; _a++) {\n        var ibm = ibms_2[_a];\n        var m = ibm instanceof _math__WEBPACK_IMPORTED_MODULE_2__.Matrix4x4 ? ibm : new _math__WEBPACK_IMPORTED_MODULE_2__.Matrix4x4();\n        // GLTF2.0 uses column major matrix\n        for (var c = 0; c < 4; c++) {\n            for (var r = 0; r < 4; r++) {\n                skinBufferView.push(m.data[r][c]);\n            }\n        }\n    }\n    // complete and clean up\n    var skinAccessor = skinBufferView.endAccessor();\n    var skinAccessor_idx = addAccessor(gltf, skinBufferView.getIndex(), skinAccessor);\n    gltfSkin.inverseBindMatrices = skinAccessor_idx;\n    skinBufferView.finalize();\n    if (!singleGLBBuffer)\n        skinBuffer.finalize();\n    return addedIndex;\n}\nfunction addAnimations(gltf, animations, nodeIndex) {\n    if (animations.length === 0)\n        return;\n    var singleGLBBuffer = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB;\n    var animBuffer = singleGLBBuffer ? gltf.extras.binChunkBuffer : addBuffer(gltf);\n    var timeBufferView = animBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.SCALAR);\n    var vec4BufferView; // ComponentType.FLOAT, DataType.VEC4\n    var vec3BufferView; // ComponentType.FLOAT, DataType.VEC3\n    if (!gltf.animations || gltf.animations.length === 0) {\n        var gltfAnim_1 = {\n            channels: [],\n            samplers: []\n        };\n        gltf.animations = [gltfAnim_1];\n    }\n    var gltfAnim = gltf.animations[0];\n    if (animations[0].name && !gltfAnim.name) // TODO: Animation names\n        gltfAnim.name = animations[0].name;\n    function _completeAnimation(animBufferView, interpType, path) {\n        var timeAccessor = timeBufferView.endAccessor();\n        var timeAccessor_idx = addAccessor(gltf, timeBufferView.getIndex(), timeAccessor);\n        var animAccessor = animBufferView.endAccessor();\n        var animAccessor_idx = addAccessor(gltf, animBufferView.getIndex(), animAccessor);\n        // then create samplers (input: times accessor idx, output: values accessor idx)\n        var sampler = {\n            \"input\": timeAccessor_idx,\n            \"output\": animAccessor_idx,\n            \"interpolation\": interpType\n        };\n        // then create channels (sampler: get sampler idx from above)\n        var channel = {\n            \"sampler\": gltfAnim.samplers.length,\n            \"target\": {\n                \"node\": nodeIndex,\n                \"path\": path\n            }\n        };\n        gltfAnim.samplers.push(sampler);\n        gltfAnim.channels.push(channel);\n    }\n    for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {\n        var anim = animations_1[_i];\n        if (!anim.keyframes || anim.keyframes.length == 0) {\n            continue;\n        }\n        // push to channels and samplers\n        var path = anim.path;\n        var isVec4 = anim.keyframes[0].value.length === 4;\n        var animBufferView = void 0;\n        if (isVec4) {\n            if (!vec4BufferView) {\n                vec4BufferView = animBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC4);\n            }\n            animBufferView = vec4BufferView;\n        }\n        else {\n            if (!vec3BufferView) {\n                vec3BufferView = animBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3);\n            }\n            animBufferView = vec3BufferView;\n        }\n        // add accessors\n        timeBufferView.startAccessor();\n        animBufferView.startAccessor();\n        var prev_interpType = anim.keyframes[0].interpType;\n        var ix = 0;\n        var total_kf = anim.keyframes.length;\n        for (var idx = 0; idx < total_kf; ++idx) {\n            var keyframe = anim.keyframes[idx];\n            var interpType = keyframe.interpType;\n            if (interpType != prev_interpType) {\n                _completeAnimation(animBufferView, prev_interpType, path);\n                timeBufferView.startAccessor();\n                animBufferView.startAccessor();\n                ix = 0;\n            }\n            var isSpline = interpType === _types__WEBPACK_IMPORTED_MODULE_0__.InterpolationMode.CUBICSPLINE;\n            if (isSpline && isVec4)\n                throw new Error(\"CUBICSPLINE for Vector4 not implemented!\");\n            var time = keyframe.time, value = keyframe.value;\n            timeBufferView.push(time);\n            if (isSpline) {\n                var spline_info = keyframe.extras;\n                var outTangent = [0, 0, 0];\n                var inTangent = [0, 0, 0];\n                if ((spline_info === null || spline_info === void 0 ? void 0 : spline_info.inTangent) && ix > 0) {\n                    inTangent = spline_info.inTangent;\n                }\n                if ((spline_info === null || spline_info === void 0 ? void 0 : spline_info.outTangent) && (idx < total_kf - 1)\n                    && anim.keyframes[idx + 1].interpType === _types__WEBPACK_IMPORTED_MODULE_0__.InterpolationMode.CUBICSPLINE) {\n                    outTangent = spline_info.outTangent;\n                }\n                var data = [inTangent, value, outTangent];\n                for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {\n                    var d = data_1[_a];\n                    for (var j = 0; j < 3; ++j) {\n                        animBufferView.push(d[j]); // aaavvvbbb, a=inTangent, v=value, b=outTangent\n                    }\n                }\n            }\n            else {\n                var tj = isVec4 ? 4 : 3;\n                for (var j = 0; j < tj; ++j) {\n                    animBufferView.push(value[j]);\n                }\n            }\n            ix++;\n            prev_interpType = interpType;\n        }\n        _completeAnimation(animBufferView, prev_interpType, path);\n    }\n    timeBufferView.finalize();\n    if (vec4BufferView)\n        vec4BufferView.finalize();\n    if (vec3BufferView)\n        vec3BufferView.finalize();\n    if (!singleGLBBuffer)\n        animBuffer.finalize();\n}\nfunction addMesh(gltf, mesh) {\n    if (!gltf.meshes)\n        gltf.meshes = [];\n    if (mesh.mode !== _types__WEBPACK_IMPORTED_MODULE_0__.MeshMode.TRIANGLES)\n        throw \"MeshMode other than TRIANGLES not currently supported\";\n    addMaterials(gltf, mesh.material);\n    var gltfMesh = {\n        primitives: [],\n    };\n    var addedIndex = gltf.meshes.length;\n    gltf.meshes.push(gltfMesh);\n    var singleGLBBuffer = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB;\n    var meshBuffer;\n    if (singleGLBBuffer) {\n        meshBuffer = gltf.extras.binChunkBuffer;\n    }\n    else {\n        meshBuffer = addBuffer(gltf);\n    }\n    var vertexBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3);\n    var vertexNormalBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3);\n    var vertexUVBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC2);\n    var vertexColorBufferView;\n    function _ensureColorBufferView() {\n        if (vertexColorBufferView)\n            return;\n        vertexColorBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC4);\n    }\n    function _completeMeshPrimitive(materialIndex) {\n        var vertexBufferAccessorInfo = vertexBufferView.endAccessor();\n        var vertexNormalBufferAccessorInfo = vertexNormalBufferView.endAccessor();\n        var vertexUVBufferAccessorInfo = vertexUVBufferView.endAccessor();\n        var primitive = {\n            attributes: {\n                POSITION: addAccessor(gltf, vertexBufferView.getIndex(), vertexBufferAccessorInfo),\n                NORMAL: addAccessor(gltf, vertexNormalBufferView.getIndex(), vertexNormalBufferAccessorInfo),\n                TEXCOORD_0: addAccessor(gltf, vertexUVBufferView.getIndex(), vertexUVBufferAccessorInfo),\n            },\n            mode: mesh.mode,\n        };\n        if (materialIndex >= 0) {\n            primitive.material = materialIndex;\n            // Only add color data if it is per-face/vertex.\n            var material = mesh.material[materialIndex];\n            if (material.vertexColorMode !== _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.NoColors) {\n                var vertexColorBufferAccessorInfo = vertexColorBufferView.endAccessor();\n                primitive.attributes[\"COLOR_0\"] =\n                    addAccessor(gltf, vertexColorBufferView.getIndex(), vertexColorBufferAccessorInfo);\n            }\n        }\n        return primitive;\n    }\n    var lastMaterialIndex = null;\n    mesh.forEachFace(function (v1, v2, v3, color, materialIndex) {\n        var currentMaterial = null;\n        if (materialIndex >= 0)\n            currentMaterial = mesh.material[materialIndex];\n        // Need to start new accessors\n        if (lastMaterialIndex !== materialIndex) {\n            // And end the previous ones.\n            if (lastMaterialIndex !== null) {\n                var primitive = _completeMeshPrimitive(lastMaterialIndex);\n                gltfMesh.primitives.push(primitive);\n            }\n            vertexBufferView.startAccessor(\"POSITION\");\n            vertexNormalBufferView.startAccessor(\"NORMAL\");\n            vertexUVBufferView.startAccessor(\"TEXCOORD_0\");\n            if (currentMaterial && currentMaterial.vertexColorMode !== _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.NoColors) {\n                _ensureColorBufferView();\n                vertexColorBufferView.startAccessor(\"COLOR_0\");\n            }\n            lastMaterialIndex = materialIndex;\n        }\n        // Positions\n        vertexBufferView.push(v1.x);\n        vertexBufferView.push(v1.y);\n        vertexBufferView.push(v1.z);\n        vertexBufferView.push(v2.x);\n        vertexBufferView.push(v2.y);\n        vertexBufferView.push(v2.z);\n        vertexBufferView.push(v3.x);\n        vertexBufferView.push(v3.y);\n        vertexBufferView.push(v3.z);\n        // Vertex normals\n        vertexNormalBufferView.push(v1.normalX);\n        vertexNormalBufferView.push(v1.normalY);\n        vertexNormalBufferView.push(v1.normalZ);\n        vertexNormalBufferView.push(v2.normalX);\n        vertexNormalBufferView.push(v2.normalY);\n        vertexNormalBufferView.push(v2.normalZ);\n        vertexNormalBufferView.push(v3.normalX);\n        vertexNormalBufferView.push(v3.normalY);\n        vertexNormalBufferView.push(v3.normalZ);\n        // Texture UV coords\n        vertexUVBufferView.push(v1.u);\n        vertexUVBufferView.push(v1.v);\n        vertexUVBufferView.push(v2.u);\n        vertexUVBufferView.push(v2.v);\n        vertexUVBufferView.push(v3.u);\n        vertexUVBufferView.push(v3.v);\n        if (currentMaterial) {\n            // Vertex colors\n            switch (currentMaterial.vertexColorMode) {\n                case _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.FaceColors:\n                    // Just duplicate the face colors 3 times.\n                    for (var v = 0; v < 3; v++) {\n                        addColorToBufferView(vertexColorBufferView, color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\n                    }\n                    break;\n                case _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.VertexColors:\n                    addColorToBufferView(vertexColorBufferView, v1.color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\n                    addColorToBufferView(vertexColorBufferView, v2.color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\n                    addColorToBufferView(vertexColorBufferView, v3.color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\n                    break;\n                // NoColors? We won't have an accessor.\n            }\n        }\n    });\n    if (lastMaterialIndex !== null) {\n        var primitive = _completeMeshPrimitive(lastMaterialIndex);\n        gltfMesh.primitives.push(primitive);\n    }\n    vertexBufferView.finalize();\n    vertexNormalBufferView.finalize();\n    vertexUVBufferView.finalize();\n    if (vertexColorBufferView)\n        vertexColorBufferView.finalize();\n    if (!singleGLBBuffer)\n        meshBuffer.finalize();\n    return addedIndex;\n}\nfunction addColorToBufferView(bufferView, color) {\n    bufferView.push((color.r * 255) | 0);\n    bufferView.push((color.g * 255) | 0);\n    bufferView.push((color.b * 255) | 0);\n    if (\"a\" in color) {\n        bufferView.push((color.a * 255) | 0);\n    }\n    else {\n        bufferView.push(0xFF);\n    }\n}\nfunction addBuffer(gltf) {\n    return new _buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer(gltf);\n}\nfunction addAccessor(gltf, bufferViewIndex, accessorInfo) {\n    if (!gltf.accessors)\n        gltf.accessors = [];\n    var addedIndex = gltf.accessors.length;\n    var componentType = accessorInfo.componentType;\n    var accessor = {\n        bufferView: bufferViewIndex,\n        byteOffset: accessorInfo.byteOffset,\n        componentType: componentType,\n        count: accessorInfo.count,\n        type: accessorInfo.type,\n        min: accessorInfo.min,\n        max: accessorInfo.max,\n    };\n    if (accessorInfo.normalized) {\n        accessor.normalized = true;\n    }\n    gltf.accessors.push(accessor);\n    return addedIndex;\n}\nfunction addMaterials(gltf, materials) {\n    var indices = [];\n    for (var _i = 0, materials_1 = materials; _i < materials_1.length; _i++) {\n        var material = materials_1[_i];\n        indices.push(addMaterial(gltf, material));\n    }\n    return indices;\n}\nfunction addMaterial(gltf, material) {\n    if (!gltf.materials)\n        gltf.materials = [];\n    var gltfMaterial = {};\n    if (material.name)\n        gltfMaterial.name = material.name;\n    if (material.alphaMode !== _types__WEBPACK_IMPORTED_MODULE_0__.AlphaMode.OPAQUE)\n        gltfMaterial.alphaMode = material.alphaMode;\n    if (material.alphaCutoff !== 0.5)\n        gltfMaterial.alphaCutoff = material.alphaCutoff;\n    if (material.doubleSided)\n        gltfMaterial.doubleSided = true;\n    if (material.pbrMetallicRoughness) {\n        if (material.pbrMetallicRoughness.baseColorFactor) {\n            gltfMaterial.pbrMetallicRoughness = {};\n            gltfMaterial.pbrMetallicRoughness.baseColorFactor = material.pbrMetallicRoughness.baseColorFactor;\n        }\n        if (material.pbrMetallicRoughness.baseColorTexture) {\n            if (!gltfMaterial.pbrMetallicRoughness)\n                gltfMaterial.pbrMetallicRoughness = {};\n            var textureIndex = addTexture(gltf, material.pbrMetallicRoughness.baseColorTexture);\n            gltfMaterial.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };\n        }\n    }\n    var addedIndex = gltf.materials.length;\n    gltf.materials.push(gltfMaterial);\n    return addedIndex;\n}\nfunction addTexture(gltf, texture) {\n    if (!gltf.textures)\n        gltf.textures = [];\n    var gltfTexture = {\n        sampler: addSampler(gltf, texture),\n        source: addImage(gltf, texture.image),\n    };\n    var addedIndex = gltf.textures.length;\n    gltf.textures.push(gltfTexture);\n    return addedIndex;\n}\nfunction addImage(gltf, image) {\n    if (!gltf.images)\n        gltf.images = [];\n    for (var i = 0; i < gltf.images.length; i++) {\n        if (image === gltf.images[i].extras) {\n            return i; // Already had an identical image.\n        }\n    }\n    var gltfImage = {\n        extras: image,\n    };\n    var bufferView;\n    switch (gltf.extras.options.imageOutputType) {\n        case _types__WEBPACK_IMPORTED_MODULE_0__.ImageOutputType.GLB:\n            bufferView = gltf.extras.binChunkBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.SCALAR);\n            bufferView.writeAsync((0,_imageutils__WEBPACK_IMPORTED_MODULE_3__.imageToArrayBuffer)(image)).then(function () {\n                bufferView.finalize();\n            });\n            gltfImage.bufferView = bufferView.getIndex();\n            gltfImage.mimeType = \"image/png\";\n            break;\n        case _types__WEBPACK_IMPORTED_MODULE_0__.ImageOutputType.DataURI:\n            gltfImage.uri = (0,_imageutils__WEBPACK_IMPORTED_MODULE_3__.imageToDataURI)(image);\n            break;\n        default: // ImageOutputType.External\n            gltf.extras.promises.push((0,_imageutils__WEBPACK_IMPORTED_MODULE_3__.imageToArrayBuffer)(image).then(function (pngBuffer) {\n                gltfImage.uri = pngBuffer; // Processed later\n            }));\n            break;\n    }\n    var addedIndex = gltf.images.length;\n    gltf.images.push(gltfImage);\n    return addedIndex;\n}\nfunction addSampler(gltf, texture) {\n    if (!gltf.samplers)\n        gltf.samplers = [];\n    var gltfSampler = {\n        wrapS: texture.wrapS,\n        wrapT: texture.wrapT,\n    };\n    for (var i = 0; i < gltf.samplers.length; i++) {\n        if (objectsEqual(gltfSampler, gltf.samplers[i])) {\n            return i; // Already had an identical sampler.\n        }\n    }\n    var addedIndex = gltf.samplers.length;\n    gltf.samplers.push(gltfSampler);\n    return addedIndex;\n}\nfunction getNodeIndex(gltf, node) {\n    if (gltf.extras.nodeIndices.has(node)) {\n        return gltf.extras.nodeIndices.get(node);\n    }\n    return -1;\n}\nfunction setNodeIndex(gltf, node, index) {\n    gltf.extras.nodeIndices.set(node, index);\n}\nfunction objectsEqual(obj1, obj2) {\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/gltf.ts?");

/***/ }),

/***/ "./src/imageutils.ts":
/*!***************************!*\
  !*** ./src/imageutils.ts ***!
  \***************************/
/*! namespace exports */
/*! export arrayBufferIsPNG [provided] [no usage info] [missing usage info prevents renaming] */
/*! export encodeBase64DataUri [provided] [no usage info] [missing usage info prevents renaming] */
/*! export imageToArrayBuffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export imageToDataURI [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"imageToDataURI\": () => /* binding */ imageToDataURI,\n/* harmony export */   \"imageToArrayBuffer\": () => /* binding */ imageToArrayBuffer,\n/* harmony export */   \"encodeBase64DataUri\": () => /* binding */ encodeBase64DataUri,\n/* harmony export */   \"arrayBufferIsPNG\": () => /* binding */ arrayBufferIsPNG\n/* harmony export */ });\n/**\n * Converts an image into a Data URI string.\n * @param image\n */\nfunction imageToDataURI(image) {\n    var canvas = _imageTypeToCanvas(image);\n    return canvas.toDataURL();\n}\n/**\n * Converts an image into an ArrayBuffer.\n * @param image\n */\nfunction imageToArrayBuffer(image) {\n    var canvas = _imageTypeToCanvas(image);\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n        promiseResolve = resolve;\n        promiseReject = reject;\n    });\n    canvas.toBlob(function (blob) {\n        if (!blob) {\n            promiseReject(\"Unable to convert image to PNG\");\n            return;\n        }\n        var reader = new FileReader();\n        reader.addEventListener(\"loadend\", function () {\n            promiseResolve(reader.result);\n        });\n        reader.readAsArrayBuffer(blob);\n    }, \"image/png\");\n    return promise;\n}\nfunction _imageTypeToCanvas(image) {\n    var canvas;\n    if (image instanceof HTMLImageElement) {\n        canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        var context_1 = canvas.getContext(\"2d\");\n        context_1.drawImage(image, 0, 0, image.width, image.height);\n    }\n    else {\n        canvas = image;\n    }\n    return canvas;\n}\n/**\n * Converts an ArrayBuffer into a base64 Data URI string.\n * @param buf\n */\nfunction encodeBase64DataUri(buf) {\n    var codes = [];\n    var uint8arr = new Uint8Array(buf);\n    for (var i = 0; i < uint8arr.length; i++) {\n        codes.push(String.fromCharCode(uint8arr[i]));\n    }\n    var b64 = btoa(codes.join(\"\"));\n    var uri = \"data:application/octet-stream;base64,\" + b64;\n    return uri;\n}\n/** Determines if an ArrayBuffer holds a PNG format image. */\nfunction arrayBufferIsPNG(buffer) {\n    // PNG starts with 89 50 4E 47 0D 0A 1A 0A\n    if (buffer.byteLength < 8)\n        return false;\n    var arr = new Uint8Array(buffer);\n    return arr[0] === 0x89\n        && arr[1] === 0x50\n        && arr[2] === 0x4E\n        && arr[3] === 0x47\n        && arr[4] === 0x0D\n        && arr[5] === 0x0A\n        && arr[6] === 0x1A\n        && arr[7] === 0x0A;\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/imageutils.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! namespace exports */
/*! export AlphaMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .AlphaMode */
/*! export Animation [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/animation.ts .Animation */
/*! export Buffer [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/buffer.ts .Buffer */
/*! export BufferOutputType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .BufferOutputType */
/*! export BufferView [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/buffer.ts .BufferView */
/*! export ComponentType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .ComponentType */
/*! export DataType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .DataType */
/*! export GLTFAsset [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/asset.ts .GLTFAsset */
/*! export ImageOutputType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .ImageOutputType */
/*! export InterpolationMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .InterpolationMode */
/*! export Material [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/material.ts .Material */
/*! export Matrix [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Matrix */
/*! export Matrix3x3 [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Matrix3x3 */
/*! export Matrix4x4 [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Matrix4x4 */
/*! export Mesh [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/mesh.ts .Mesh */
/*! export MeshMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .MeshMode */
/*! export Node [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/node.ts .Node */
/*! export Quaternion [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Quaternion */
/*! export RGBAColor [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .RGBAColor */
/*! export RGBColor [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .RGBColor */
/*! export Scene [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/scene.ts .Scene */
/*! export Skin [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/skin.ts .Skin */
/*! export Texture [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/texture.ts .Texture */
/*! export Transformation [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .Transformation */
/*! export Vector3 [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Vector3 */
/*! export Vertex [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/vertex.ts .Vertex */
/*! export VertexColorMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .VertexColorMode */
/*! export WrappingMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .WrappingMode */
/*! export exportGLB [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export exportGLTF [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export exportGLTFZip [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export glTFAssetFromTHREE [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/threejs.ts .glTFAssetFromTHREE */
/*! other exports [not provided] [maybe used in main (runtime-defined)] */
/*! runtime requirements: __webpack_require__, __webpack_exports__, __webpack_require__.d, __webpack_require__.r, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFAsset\": () => /* reexport safe */ _asset__WEBPACK_IMPORTED_MODULE_0__.GLTFAsset,\n/* harmony export */   \"Scene\": () => /* reexport safe */ _scene__WEBPACK_IMPORTED_MODULE_1__.Scene,\n/* harmony export */   \"Node\": () => /* reexport safe */ _node__WEBPACK_IMPORTED_MODULE_2__.Node,\n/* harmony export */   \"Mesh\": () => /* reexport safe */ _mesh__WEBPACK_IMPORTED_MODULE_3__.Mesh,\n/* harmony export */   \"Material\": () => /* reexport safe */ _material__WEBPACK_IMPORTED_MODULE_4__.Material,\n/* harmony export */   \"Texture\": () => /* reexport safe */ _texture__WEBPACK_IMPORTED_MODULE_5__.Texture,\n/* harmony export */   \"Vertex\": () => /* reexport safe */ _vertex__WEBPACK_IMPORTED_MODULE_6__.Vertex,\n/* harmony export */   \"Skin\": () => /* reexport safe */ _skin__WEBPACK_IMPORTED_MODULE_7__.Skin,\n/* harmony export */   \"Animation\": () => /* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_8__.Animation,\n/* harmony export */   \"Vector3\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Vector3,\n/* harmony export */   \"Quaternion\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Quaternion,\n/* harmony export */   \"Matrix\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Matrix,\n/* harmony export */   \"Matrix3x3\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Matrix3x3,\n/* harmony export */   \"Matrix4x4\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Matrix4x4,\n/* harmony export */   \"glTFAssetFromTHREE\": () => /* reexport safe */ _threejs__WEBPACK_IMPORTED_MODULE_10__.glTFAssetFromTHREE,\n/* harmony export */   \"AlphaMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.AlphaMode,\n/* harmony export */   \"ComponentType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.ComponentType,\n/* harmony export */   \"DataType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.DataType,\n/* harmony export */   \"MeshMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.MeshMode,\n/* harmony export */   \"RGBColor\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.RGBColor,\n/* harmony export */   \"RGBAColor\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.RGBAColor,\n/* harmony export */   \"VertexColorMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.VertexColorMode,\n/* harmony export */   \"WrappingMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.WrappingMode,\n/* harmony export */   \"InterpolationMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.InterpolationMode,\n/* harmony export */   \"Transformation\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.Transformation,\n/* harmony export */   \"ImageOutputType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType,\n/* harmony export */   \"BufferOutputType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType,\n/* harmony export */   \"Buffer\": () => /* reexport safe */ _buffer__WEBPACK_IMPORTED_MODULE_12__.Buffer,\n/* harmony export */   \"BufferView\": () => /* reexport safe */ _buffer__WEBPACK_IMPORTED_MODULE_12__.BufferView,\n/* harmony export */   \"exportGLTF\": () => /* binding */ exportGLTF,\n/* harmony export */   \"exportGLTFZip\": () => /* binding */ exportGLTFZip,\n/* harmony export */   \"exportGLB\": () => /* binding */ exportGLB\n/* harmony export */ });\n/* harmony import */ var _asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asset */ \"./src/asset.ts\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene */ \"./src/scene.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh */ \"./src/mesh.ts\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material */ \"./src/material.ts\");\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture */ \"./src/texture.ts\");\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vertex */ \"./src/vertex.ts\");\n/* harmony import */ var _skin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./skin */ \"./src/skin.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n/* harmony import */ var _threejs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threejs */ \"./src/threejs.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./buffer */ \"./src/buffer.ts\");\n/* harmony import */ var _gltf__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gltf */ \"./src/gltf.ts\");\n/* harmony import */ var _imageutils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./imageutils */ \"./src/imageutils.ts\");\n/* harmony import */ var _glb__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./glb */ \"./src/glb.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar MODEL_NAME_GLTF = \"model.gltf\";\nvar MODEL_NAME_GLB = \"model.glb\";\n/**\n * Creates a glTF model from a GLTFAsset structure.\n * @param asset GLTFAsset model structure\n * @param options Export options\n * @returns Promise for an object, each key pointing to a file.\n */\nfunction exportGLTF(asset, options) {\n    return __awaiter(this, void 0, void 0, function () {\n        var gltf, promises, currentData, currentImg, binChunkBuffer;\n        return __generator(this, function (_a) {\n            options = options || {};\n            gltf = (0,_gltf__WEBPACK_IMPORTED_MODULE_13__.createEmptyGLTF)();\n            gltf.asset.copyright = asset.copyright;\n            gltf.asset.generator = asset.generator;\n            gltf.extras.options = options;\n            (0,_gltf__WEBPACK_IMPORTED_MODULE_13__.addScenes)(gltf, asset);\n            promises = gltf.extras.promises;\n            currentData = 1;\n            currentImg = 1;\n            binChunkBuffer = null;\n            return [2 /*return*/, Promise.all(promises).then(function () {\n                    var output = {};\n                    delete gltf.extras;\n                    var jsonSpacing = typeof options.jsonSpacing === \"number\" ? options.jsonSpacing : 4;\n                    var gltfString = JSON.stringify(gltf, function (key, value) {\n                        if (key === \"extras\")\n                            return undefined;\n                        if (value instanceof ArrayBuffer) {\n                            var filename = void 0;\n                            if ((0,_imageutils__WEBPACK_IMPORTED_MODULE_15__.arrayBufferIsPNG)(value)) {\n                                switch (options.imageOutputType) {\n                                    case _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.DataURI:\n                                    case _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.GLB:\n                                        break; // Not applicable\n                                    default: // ImageOutputType.External\n                                        filename = \"img\" + currentImg + \".png\";\n                                        currentImg++;\n                                        output[filename] = value;\n                                        return filename;\n                                }\n                            }\n                            switch (options.bufferOutputType) {\n                                case _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.DataURI:\n                                    return (0,_imageutils__WEBPACK_IMPORTED_MODULE_15__.encodeBase64DataUri)(value);\n                                case _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.GLB:\n                                    if (binChunkBuffer)\n                                        throw new Error(\"Already encountered an ArrayBuffer, there should only be one in the GLB format.\");\n                                    binChunkBuffer = value;\n                                    return undefined;\n                                default: // BufferOutputType.External\n                                    filename = \"data\" + currentData + \".bin\";\n                                    currentData++;\n                                    output[filename] = value;\n                                    return filename;\n                            }\n                        }\n                        return value;\n                    }, jsonSpacing);\n                    var doingGLB = options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.GLB\n                        || options.imageOutputType === _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.GLB;\n                    if (doingGLB) {\n                        output[MODEL_NAME_GLB] = (0,_glb__WEBPACK_IMPORTED_MODULE_14__.createGLBBuffer)(gltfString, binChunkBuffer);\n                    }\n                    else {\n                        output[MODEL_NAME_GLTF] = gltfString;\n                    }\n                    return output;\n                })];\n        });\n    });\n}\n/**\n * Creates a ZIP file of a glTF model from a GLTFAsset structure.\n * @param asset GLTFAsset model structure\n * @param jsZip JSZip instance\n * @param options Export options\n * @returns A Promise to receive a ZIP blob is returned instead.\n */\nfunction exportGLTFZip(asset, jsZip, options) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, exportGLTF(asset, options).then(function (output) {\n                    var zip = new jsZip();\n                    for (var filename in output) {\n                        zip.file(filename, output[filename]);\n                    }\n                    return zip.generateAsync({ type: \"blob\" });\n                })];\n        });\n    });\n}\n/**\n * Creates a GLB binary format glTF model from a GLTFAsset structure.\n * @param asset GLTFAsset model structure\n * @returns An ArrayBuffer containing the GLB file.\n */\nfunction exportGLB(asset) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, exportGLTF(asset, {\n                    bufferOutputType: _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.GLB,\n                    imageOutputType: _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.GLB,\n                    jsonSpacing: 0,\n                }).then(function (output) {\n                    return output[MODEL_NAME_GLB];\n                })];\n        });\n    });\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/index.ts?");

/***/ }),

/***/ "./src/material.ts":
/*!*************************!*\
  !*** ./src/material.ts ***!
  \*************************/
/*! namespace exports */
/*! export Material [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Material\": () => /* binding */ Material\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Material = /** @class */ (function () {\n    function Material() {\n        this.name = \"\";\n        this.alphaCutoff = 0.5;\n        this.alphaMode = _types__WEBPACK_IMPORTED_MODULE_0__.AlphaMode.OPAQUE;\n        this.doubleSided = false;\n        this.vertexColorMode = _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.NoColors;\n        this.pbrMetallicRoughness = {\n            metallicFactor: 1.0,\n            roughnessFactor: 1.0,\n        };\n    }\n    return Material;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/material.ts?");

/***/ }),

/***/ "./src/math.ts":
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/*! namespace exports */
/*! export Matrix [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Matrix3x3 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Matrix4x4 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Quaternion [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Vector3 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export degreesToRadians [provided] [no usage info] [missing usage info prevents renaming] */
/*! export toQuaternion [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector3\": () => /* binding */ Vector3,\n/* harmony export */   \"Quaternion\": () => /* binding */ Quaternion,\n/* harmony export */   \"toQuaternion\": () => /* binding */ toQuaternion,\n/* harmony export */   \"degreesToRadians\": () => /* binding */ degreesToRadians,\n/* harmony export */   \"Matrix\": () => /* binding */ Matrix,\n/* harmony export */   \"Matrix3x3\": () => /* binding */ Matrix3x3,\n/* harmony export */   \"Matrix4x4\": () => /* binding */ Matrix4x4\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Vector3 = /** @class */ (function () {\n    function Vector3(x, y, z) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    Vector3.prototype.toArray = function () {\n        return [this.x, this.y, this.z];\n    };\n    return Vector3;\n}());\n\nvar Quaternion = /** @class */ (function () {\n    function Quaternion(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    Quaternion.prototype.toArray = function () {\n        return [this.x, this.y, this.z, this.w];\n    };\n    return Quaternion;\n}());\n\nfunction toQuaternion(x, y, z) {\n    var cy = Math.cos(z * 0.5);\n    var sy = Math.sin(z * 0.5);\n    var cr = Math.cos(x * 0.5);\n    var sr = Math.sin(x * 0.5);\n    var cp = Math.cos(y * 0.5);\n    var sp = Math.sin(y * 0.5);\n    return new Quaternion(cy * sr * cp - sy * cr * sp, cy * cr * sp + sy * sr * cp, sy * cr * cp - cy * sr * sp, cy * cr * cp + sy * sr * sp);\n}\nfunction degreesToRadians(degrees) {\n    return degrees * Math.PI / 180;\n}\n// NxN Square Matrix\n// Make sure to store as row-major\nvar Matrix = /** @class */ (function () {\n    function Matrix(rows) {\n        if (rows === void 0) { rows = 4; }\n        this.data = Matrix.Identity(rows);\n    }\n    Object.defineProperty(Matrix.prototype, \"m\", {\n        /**\n         * Return the matrix values\n         */\n        get: function () {\n            return this.data;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"rows\", {\n        get: function () {\n            return this.data.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"cols\", {\n        get: function () {\n            if (this.rows === 0)\n                return 0;\n            return this.data[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Initialize an identity square matrix\n     */\n    Matrix.Identity = function (rows) {\n        var M = [];\n        for (var r = 0; r < rows; ++r) {\n            var Mrow = [];\n            for (var c = 0; c < rows; ++c) {\n                Mrow.push(r === c ? 1 : 0);\n            }\n            M.push(Mrow);\n        }\n        return M;\n    };\n    Matrix.IsIdentity = function (matrix) {\n        var rows = matrix.rows;\n        var cols = matrix.cols;\n        if (rows !== cols)\n            return false;\n        for (var r = 0; r < rows; ++r) {\n            for (var c = 0; c < cols; ++c) {\n                if (matrix.data[r][c] != (r === c ? 1 : 0))\n                    return false;\n            }\n        }\n        return true;\n    };\n    return Matrix;\n}());\n\nvar Matrix3x3 = /** @class */ (function (_super) {\n    __extends(Matrix3x3, _super);\n    function Matrix3x3() {\n        return _super.call(this, 3) || this;\n    }\n    Matrix3x3.Identity = function () {\n        return Matrix.Identity(3);\n    };\n    Matrix3x3.IsIdentity = function (matrix) {\n        if (matrix.rows !== 3 || matrix.cols !== 3)\n            return false;\n        return Matrix.IsIdentity(matrix);\n    };\n    return Matrix3x3;\n}(Matrix));\n\nvar Matrix4x4 = /** @class */ (function (_super) {\n    __extends(Matrix4x4, _super);\n    function Matrix4x4() {\n        return _super.call(this, 4) || this;\n    }\n    Matrix4x4.Identity = function () {\n        return Matrix.Identity(4);\n    };\n    Matrix4x4.IsIdentity = function (matrix) {\n        if (matrix.rows !== 4 || matrix.cols !== 4)\n            return false;\n        return Matrix.IsIdentity(matrix);\n    };\n    return Matrix4x4;\n}(Matrix));\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/math.ts?");

/***/ }),

/***/ "./src/mesh.ts":
/*!*********************!*\
  !*** ./src/mesh.ts ***!
  \*********************/
/*! namespace exports */
/*! export Mesh [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mesh\": () => /* binding */ Mesh\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Mesh = /** @class */ (function () {\n    function Mesh() {\n        this.material = [];\n        this.mode = _types__WEBPACK_IMPORTED_MODULE_0__.MeshMode.TRIANGLES;\n        this._vertices = [];\n        this._faceColors = [];\n        this._materialIndices = [];\n    }\n    Mesh.prototype.addFace = function (v1, v2, v3, color, materialIndex) {\n        this._vertices.push(v1);\n        this._vertices.push(v2);\n        this._vertices.push(v3);\n        this._faceColors.push(color);\n        if (typeof materialIndex === \"undefined\")\n            materialIndex = -1;\n        this._materialIndices.push(materialIndex);\n    };\n    Mesh.prototype.forEachFace = function (fn) {\n        for (var i = 0; i < this._vertices.length / 3; i++) {\n            fn(this._vertices[(i * 3)], this._vertices[(i * 3) + 1], this._vertices[(i * 3) + 2], this._faceColors[i], this._materialIndices[i]);\n        }\n    };\n    return Mesh;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/mesh.ts?");

/***/ }),

/***/ "./src/node.ts":
/*!*********************!*\
  !*** ./src/node.ts ***!
  \*********************/
/*! namespace exports */
/*! export Node [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Node\": () => /* binding */ Node\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n\n\nvar Node = /** @class */ (function () {\n    function Node(name) {\n        if (name === void 0) { name = \"\"; }\n        this.name = \"\";\n        this.animations = [];\n        this._nodes = [];\n        this.name = name;\n    }\n    Node.prototype.addNode = function (node) {\n        if (this._nodes.indexOf(node) >= 0)\n            return;\n        // throw new Error(\"Node passed to addNode was added prior.\");\n        this._nodes.push(node);\n    };\n    Node.prototype.removeNode = function (node) {\n        var idx = node instanceof Node ? this._nodes.indexOf(node) : node;\n        if (idx >= 0 && idx < this._nodes.length)\n            this._nodes.splice(idx, 1);\n        return idx;\n    };\n    Node.prototype.forEachNode = function (fn) {\n        this._nodes.forEach(fn);\n    };\n    Node.prototype.addAnimation = function (animation) {\n        this.animations.push(animation);\n    };\n    Node.prototype.removeAnimation = function (animation) {\n        var idx = animation instanceof _animation__WEBPACK_IMPORTED_MODULE_1__.Animation ? this.animations.indexOf(animation) : animation;\n        if (idx >= 0 && idx < this.animations.length)\n            this.animations.splice(idx, 1);\n        return idx;\n    };\n    Node.prototype.setTranslation = function (x, y, z) {\n        this._translation = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);\n    };\n    Node.prototype.getTranslation = function () {\n        return this._translation || new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    };\n    Node.prototype.setRotationDegrees = function (x, y, z) {\n        this.setRotationRadians((0,_math__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(x), (0,_math__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(y), (0,_math__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(z));\n    };\n    Node.prototype.setRotationRadians = function (x, y, z) {\n        this._rotation = (0,_math__WEBPACK_IMPORTED_MODULE_0__.toQuaternion)(x, y, z);\n    };\n    Node.prototype.setRotationQuaternion = function (x, y, z, w) {\n        this._rotation = new _math__WEBPACK_IMPORTED_MODULE_0__.Quaternion(x, y, z, w);\n    };\n    Node.prototype.getRotationQuaternion = function () {\n        return this._rotation || new _math__WEBPACK_IMPORTED_MODULE_0__.Quaternion(0, 0, 0, 1);\n    };\n    Node.prototype.setScale = function (x, y, z) {\n        this._scale = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);\n    };\n    Node.prototype.getScale = function () {\n        return this._scale || new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n    };\n    return Node;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/node.ts?");

/***/ }),

/***/ "./src/scene.ts":
/*!**********************!*\
  !*** ./src/scene.ts ***!
  \**********************/
/*! namespace exports */
/*! export Scene [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => /* binding */ Scene\n/* harmony export */ });\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n\nvar Scene = /** @class */ (function () {\n    function Scene(name) {\n        if (name === void 0) { name = \"\"; }\n        this.name = \"\";\n        this._nodes = [];\n        this.name = name;\n    }\n    Scene.prototype.addNode = function (node) {\n        if (this._nodes.indexOf(node) >= 0)\n            return;\n        // throw new Error(\"Node passed to addNode was added prior.\");\n        this._nodes.push(node);\n    };\n    Scene.prototype.removeNode = function (node) {\n        var idx = node instanceof _node__WEBPACK_IMPORTED_MODULE_0__.Node ? this._nodes.indexOf(node) : node;\n        if (idx >= 0 && idx < this._nodes.length)\n            this._nodes.splice(idx, 1);\n        return idx;\n    };\n    Scene.prototype.forEachNode = function (fn) {\n        this._nodes.forEach(fn);\n    };\n    return Scene;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/scene.ts?");

/***/ }),

/***/ "./src/skin.ts":
/*!*********************!*\
  !*** ./src/skin.ts ***!
  \*********************/
/*! namespace exports */
/*! export Skin [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Skin\": () => /* binding */ Skin\n/* harmony export */ });\nvar Skin = /** @class */ (function () {\n    function Skin(skeletonNode, name) {\n        if (skeletonNode === void 0) { skeletonNode = null; }\n        if (name === void 0) { name = \"\"; }\n        this.name = \"\";\n        this.skeletonNode = skeletonNode;\n        this.name = name;\n    }\n    return Skin;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/skin.ts?");

/***/ }),

/***/ "./src/texture.ts":
/*!************************!*\
  !*** ./src/texture.ts ***!
  \************************/
/*! namespace exports */
/*! export Texture [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Texture\": () => /* binding */ Texture\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Texture = /** @class */ (function () {\n    function Texture(image) {\n        this.wrapS = _types__WEBPACK_IMPORTED_MODULE_0__.WrappingMode.CLAMP_TO_EDGE;\n        this.wrapT = _types__WEBPACK_IMPORTED_MODULE_0__.WrappingMode.CLAMP_TO_EDGE;\n        this.image = image;\n    }\n    Object.defineProperty(Texture.prototype, \"image\", {\n        get: function () {\n            return this.__image;\n        },\n        set: function (val) {\n            if (!val) {\n                throw new Error(\"Why is the texture image being unset?\");\n            }\n            this.__image = val;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Texture;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/texture.ts?");

/***/ }),

/***/ "./src/threejs.ts":
/*!************************!*\
  !*** ./src/threejs.ts ***!
  \************************/
/*! namespace exports */
/*! export glTFAssetFromTHREE [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"glTFAssetFromTHREE\": () => /* binding */ glTFAssetFromTHREE\n/* harmony export */ });\n/* harmony import */ var _asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asset */ \"./src/asset.ts\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene */ \"./src/scene.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh */ \"./src/mesh.ts\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material */ \"./src/material.ts\");\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture */ \"./src/texture.ts\");\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vertex */ \"./src/vertex.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\n\n\n\n\n\n\n\nfunction glTFAssetFromTHREE(obj) {\n    var asset = new _asset__WEBPACK_IMPORTED_MODULE_0__.GLTFAsset();\n    var scene = new _scene__WEBPACK_IMPORTED_MODULE_1__.Scene();\n    scene.name = obj.name;\n    asset.addScene(scene);\n    scene.addNode(NodeFromTHREE(obj));\n    return asset;\n}\nfunction NodeFromTHREE(obj) {\n    var node = new _node__WEBPACK_IMPORTED_MODULE_2__.Node();\n    node.name = obj.name;\n    if (isTHREEMesh(obj)) {\n        node.mesh = MeshFromTHREE(obj);\n    }\n    else {\n        node.setTranslation(obj.position.x, obj.position.y, obj.position.z);\n        node.setRotationRadians(obj.rotation.x, obj.rotation.y, obj.rotation.z);\n        node.setScale(obj.scale.x, obj.scale.y, obj.scale.z);\n        for (var _i = 0, _a = obj.children; _i < _a.length; _i++) {\n            var child = _a[_i];\n            node.addNode(NodeFromTHREE(child));\n        }\n    }\n    return node;\n}\nfunction MeshFromTHREE(obj) {\n    var mesh = new _mesh__WEBPACK_IMPORTED_MODULE_3__.Mesh();\n    var threeGeometry = obj.geometry;\n    if (isTHREEGeometry(threeGeometry)) {\n        for (var i = 0; i < threeGeometry.faces.length; i++) {\n            var face = threeGeometry.faces[i];\n            var faceColor = new _types__WEBPACK_IMPORTED_MODULE_7__.RGBColor();\n            faceColor.r = face.color.r;\n            faceColor.g = face.color.g;\n            faceColor.b = face.color.b;\n            mesh.addFace(VertexFromTHREE(threeGeometry, i, face.a, 0), VertexFromTHREE(threeGeometry, i, face.b, 1), VertexFromTHREE(threeGeometry, i, face.c, 2), faceColor, face.materialIndex);\n        }\n        mesh.material = MaterialsFromTHREE(obj.material);\n    }\n    else {\n        throw new Error(\"BufferGeometry (or other type) not supported.\");\n    }\n    return mesh;\n}\nfunction MaterialsFromTHREE(threeMaterial) {\n    var materials = [];\n    if (!Array.isArray(threeMaterial)) {\n        threeMaterial = [threeMaterial];\n    }\n    for (var _i = 0, threeMaterial_1 = threeMaterial; _i < threeMaterial_1.length; _i++) {\n        var mat = threeMaterial_1[_i];\n        materials.push(MaterialFromTHREE(mat));\n    }\n    return materials;\n}\nfunction MaterialFromTHREE(threeMaterial) {\n    var material = new _material__WEBPACK_IMPORTED_MODULE_4__.Material();\n    material.doubleSided = threeMaterial.side === 2; // THREE.DoubleSide;\n    if (isTHREEMeshBasicMaterial(threeMaterial)) {\n        material.pbrMetallicRoughness.metallicFactor = 0;\n        material.pbrMetallicRoughness.roughnessFactor = 0;\n        if (threeMaterial.transparent) {\n            material.alphaMode = _types__WEBPACK_IMPORTED_MODULE_7__.AlphaMode.MASK;\n            material.alphaCutoff = threeMaterial.alphaTest;\n        }\n        material.vertexColorMode = threeMaterial.vertexColors ? _types__WEBPACK_IMPORTED_MODULE_7__.VertexColorMode.VertexColors : _types__WEBPACK_IMPORTED_MODULE_7__.VertexColorMode.NoColors;\n        if (threeMaterial.color && !threeMaterial.vertexColors) {\n            material.pbrMetallicRoughness.baseColorFactor = [\n                threeMaterial.color.r,\n                threeMaterial.color.g,\n                threeMaterial.color.b,\n                1\n            ];\n        }\n        if (threeMaterial.map) {\n            var texture = new _texture__WEBPACK_IMPORTED_MODULE_5__.Texture(threeMaterial.map.image);\n            texture.wrapS = WrappingModeFromTHREE(threeMaterial.map.wrapS);\n            texture.wrapT = WrappingModeFromTHREE(threeMaterial.map.wrapT);\n            material.pbrMetallicRoughness.baseColorTexture = texture;\n        }\n    }\n    else {\n        throw new Error(threeMaterial.type + \" is currently not supported.\");\n    }\n    return material;\n}\nfunction VertexFromTHREE(threeGeometry, faceIndex, vertexIndex, vertexRelIndex) {\n    var vertex = new _vertex__WEBPACK_IMPORTED_MODULE_6__.Vertex();\n    var threeVertex = threeGeometry.vertices[vertexIndex];\n    vertex.x = threeVertex.x;\n    vertex.y = threeVertex.y;\n    vertex.z = threeVertex.z;\n    if (threeGeometry.faceVertexUvs[0] && threeGeometry.faceVertexUvs[0][faceIndex]\n        && threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex]) {\n        vertex.u = threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex].x;\n        vertex.v = threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex].y;\n    }\n    var threeFace = threeGeometry.faces[faceIndex];\n    if (threeFace.vertexNormals[vertexRelIndex]) {\n        vertex.normalX = threeFace.vertexNormals[vertexRelIndex].x;\n        vertex.normalY = threeFace.vertexNormals[vertexRelIndex].y;\n        vertex.normalZ = threeFace.vertexNormals[vertexRelIndex].z;\n    }\n    if (threeFace.vertexColors[vertexRelIndex]) {\n        vertex.color = new _types__WEBPACK_IMPORTED_MODULE_7__.RGBColor();\n        vertex.color.r = threeFace.vertexColors[vertexRelIndex].r;\n        vertex.color.g = threeFace.vertexColors[vertexRelIndex].g;\n        vertex.color.b = threeFace.vertexColors[vertexRelIndex].b;\n    }\n    return vertex;\n}\nfunction WrappingModeFromTHREE(mode) {\n    switch (mode) {\n        case 1000: // THREE.RepeatWrapping\n            return _types__WEBPACK_IMPORTED_MODULE_7__.WrappingMode.REPEAT;\n        case 1002: // THREE.MirroredRepeatWrapping\n            return _types__WEBPACK_IMPORTED_MODULE_7__.WrappingMode.MIRRORED_REPEAT;\n        case 1001: // THREE.ClampToEdgeWrapping\n        default:\n            return _types__WEBPACK_IMPORTED_MODULE_7__.WrappingMode.CLAMP_TO_EDGE;\n    }\n}\nfunction isTHREEMesh(obj) {\n    return obj.type === \"Mesh\";\n}\nfunction isTHREEGeometry(obj) {\n    return obj.type === \"Geometry\";\n}\nfunction isTHREEMeshBasicMaterial(obj) {\n    return obj.type === \"MeshBasicMaterial\";\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/threejs.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/*! namespace exports */
/*! export AlphaMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export BufferOutputType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ComponentType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DataType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ImageOutputType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export InterpolationMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MeshMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RGBAColor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RGBColor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Transformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export VertexColorMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WrappingMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BufferOutputType\": () => /* binding */ BufferOutputType,\n/* harmony export */   \"ImageOutputType\": () => /* binding */ ImageOutputType,\n/* harmony export */   \"ComponentType\": () => /* binding */ ComponentType,\n/* harmony export */   \"DataType\": () => /* binding */ DataType,\n/* harmony export */   \"MeshMode\": () => /* binding */ MeshMode,\n/* harmony export */   \"WrappingMode\": () => /* binding */ WrappingMode,\n/* harmony export */   \"AlphaMode\": () => /* binding */ AlphaMode,\n/* harmony export */   \"RGBColor\": () => /* binding */ RGBColor,\n/* harmony export */   \"RGBAColor\": () => /* binding */ RGBAColor,\n/* harmony export */   \"VertexColorMode\": () => /* binding */ VertexColorMode,\n/* harmony export */   \"InterpolationMode\": () => /* binding */ InterpolationMode,\n/* harmony export */   \"Transformation\": () => /* binding */ Transformation\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar BufferOutputType;\n(function (BufferOutputType) {\n    /** Create separate files for binary buffers (default) */\n    BufferOutputType[BufferOutputType[\"External\"] = 0] = \"External\";\n    /** Embed buffers as data URIs. */\n    BufferOutputType[BufferOutputType[\"DataURI\"] = 1] = \"DataURI\";\n    /**\n     * Embed buffers as chunks in a GLB buffer.\n     */\n    BufferOutputType[BufferOutputType[\"GLB\"] = 2] = \"GLB\";\n})(BufferOutputType || (BufferOutputType = {}));\nvar ImageOutputType;\n(function (ImageOutputType) {\n    /** Create separate files for images (default) */\n    ImageOutputType[ImageOutputType[\"External\"] = 0] = \"External\";\n    /** Embed images as data URIs. */\n    ImageOutputType[ImageOutputType[\"DataURI\"] = 1] = \"DataURI\";\n    /**\n     * Embed images as chunks in a GLB buffer.\n     */\n    ImageOutputType[ImageOutputType[\"GLB\"] = 2] = \"GLB\";\n})(ImageOutputType || (ImageOutputType = {}));\nvar ComponentType;\n(function (ComponentType) {\n    ComponentType[ComponentType[\"BYTE\"] = 5120] = \"BYTE\";\n    ComponentType[ComponentType[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    ComponentType[ComponentType[\"SHORT\"] = 5122] = \"SHORT\";\n    ComponentType[ComponentType[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    ComponentType[ComponentType[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n    ComponentType[ComponentType[\"FLOAT\"] = 5126] = \"FLOAT\";\n})(ComponentType || (ComponentType = {}));\nvar DataType;\n(function (DataType) {\n    DataType[\"SCALAR\"] = \"SCALAR\";\n    DataType[\"VEC2\"] = \"VEC2\";\n    DataType[\"VEC3\"] = \"VEC3\";\n    DataType[\"VEC4\"] = \"VEC4\";\n    DataType[\"MAT2\"] = \"MAT2\";\n    DataType[\"MAT3\"] = \"MAT3\";\n    DataType[\"MAT4\"] = \"MAT4\";\n})(DataType || (DataType = {}));\nvar MeshMode;\n(function (MeshMode) {\n    MeshMode[MeshMode[\"POINTS\"] = 0] = \"POINTS\";\n    MeshMode[MeshMode[\"LINES\"] = 1] = \"LINES\";\n    MeshMode[MeshMode[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n    MeshMode[MeshMode[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n    MeshMode[MeshMode[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n    MeshMode[MeshMode[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n    MeshMode[MeshMode[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(MeshMode || (MeshMode = {}));\nvar WrappingMode;\n(function (WrappingMode) {\n    WrappingMode[WrappingMode[\"CLAMP_TO_EDGE\"] = 33071] = \"CLAMP_TO_EDGE\";\n    WrappingMode[WrappingMode[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n    WrappingMode[WrappingMode[\"REPEAT\"] = 10497] = \"REPEAT\";\n})(WrappingMode || (WrappingMode = {}));\nvar AlphaMode;\n(function (AlphaMode) {\n    AlphaMode[\"OPAQUE\"] = \"OPAQUE\";\n    AlphaMode[\"MASK\"] = \"MASK\";\n    AlphaMode[\"BLEND\"] = \"BLEND\";\n})(AlphaMode || (AlphaMode = {}));\nvar RGBColor = /** @class */ (function () {\n    function RGBColor() {\n        /** Red, between 0 and 1. */\n        this.r = 1;\n        /** Green, between 0 and 1 */\n        this.g = 1;\n        /** Blue, between 0 and 1 */\n        this.b = 1;\n    }\n    return RGBColor;\n}());\n\nvar RGBAColor = /** @class */ (function (_super) {\n    __extends(RGBAColor, _super);\n    function RGBAColor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Alpha, between 0 and 1 */\n        _this.a = 1;\n        return _this;\n    }\n    return RGBAColor;\n}(RGBColor));\n\n// Matches THREE Colors\nvar VertexColorMode;\n(function (VertexColorMode) {\n    VertexColorMode[VertexColorMode[\"NoColors\"] = 0] = \"NoColors\";\n    VertexColorMode[VertexColorMode[\"FaceColors\"] = 1] = \"FaceColors\";\n    VertexColorMode[VertexColorMode[\"VertexColors\"] = 2] = \"VertexColors\";\n})(VertexColorMode || (VertexColorMode = {}));\nvar InterpolationMode;\n(function (InterpolationMode) {\n    InterpolationMode[\"LINEAR\"] = \"LINEAR\";\n    InterpolationMode[\"STEP\"] = \"STEP\";\n    InterpolationMode[\"CUBICSPLINE\"] = \"CUBICSPLINE\";\n})(InterpolationMode || (InterpolationMode = {}));\nvar Transformation;\n(function (Transformation) {\n    Transformation[\"TRANSLATION\"] = \"translation\";\n    Transformation[\"ROTATION\"] = \"rotation\";\n    Transformation[\"SCALE\"] = \"scale\";\n})(Transformation || (Transformation = {}));\n\n\n//# sourceURL=webpack://GLTFUtils/./src/types.ts?");

/***/ }),

/***/ "./src/vertex.ts":
/*!***********************!*\
  !*** ./src/vertex.ts ***!
  \***********************/
/*! namespace exports */
/*! export Vertex [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vertex\": () => /* binding */ Vertex\n/* harmony export */ });\nvar Vertex = /** @class */ (function () {\n    function Vertex() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.u = 0;\n        this.v = 0;\n        this.normalX = 0;\n        this.normalY = 0;\n        this.normalZ = 0;\n    }\n    return Vertex;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/vertex.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.ts");
/******/ })()
;
});